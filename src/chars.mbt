// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
let ranges_is_digit : Array[Char] = ['0', '9']

///|
let ranges_is_not_digit : Array[Char] = ['\u{0}', '/', ':', '\u{10FFFF}']

///|
let ranges_is_word : Array[Char] = ['0', '9', 'A', 'Z', '_', '_', 'a', 'z']

///|
let ranges_is_not_word : Array[Char] = [
  '\u{0}', '/', ':', '@', '[', '^', '`', '`', '{', '\u{10FFFF}',
]

///|
let ranges_any : Array[Char] = ['\u{0}', '\u{10FFFF}']

///|
let ranges_any_not_new_line : Array[Char] = [
  '\u{0}', '\u{9}', '\u{11}', '\u{10FFFF}',
]

///|
/// white space: \u{9}, \u{B}, \u{C}, \u{FEFF}, Zs
/// line terminator: \u{A}, \u{D}, \u{2028}, \u{2029}
/// references:
/// - https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-white-space
/// - https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-line-terminators
/// - https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
let ranges_is_white_space_or_line_terminator : Array[Char] = [
  '\u{9}', '\u{D}', '\u{20}', '\u{20}', '\u{A0}', '\u{A0}', '\u{1680}', '\u{1680}',
  '\u{2000}', '\u{200A}', '\u{2028}', '\u{2029}', '\u{202F}', '\u{202F}', '\u{205F}',
  '\u{205F}', '\u{3000}', '\u{3000}', '\u{FEFF}', '\u{FEFF}',
]

///|
let ranges_is_not_white_space_or_line_terminator : Array[Char] = [
  '\u{00}', '\u{8}', '\u{E}', '\u{1F}', '\u{21}', '\u{9f}', '\u{A1}', '\u{167F}',
  '\u{1681}', '\u{1FFF}', '\u{200B}', '\u{2027}', '\u{202a}', '\u{202E}', '\u{2030}',
  '\u{205E}', '\u{2060}', '\u{2FFF}', '\u{3001}', '\u{FEFE}', '\u{FF00}', '\u{10ffff}',
]

///|
test "ordered range" {
  for
    range in [
      ranges_is_digit, ranges_is_not_digit, ranges_is_word, ranges_is_not_word, ranges_any,
      ranges_any_not_new_line, ranges_is_white_space_or_line_terminator,
    ] {
    assert_eq(simplify_char_ranges(range), range)
  }
}

///|
/// TODO: consider unicode mode
fn is_word_char_at(input : @string.View, sp : Int) -> Bool {
  if sp == -1 || sp == input.length() {
    return false
  }
  let c = input.char_at(sp)
  is_word_char(c)
}

///|
fn is_word_char(c : Char) -> Bool {
  // Check if the character is a word character (alphanumeric or underscore)
  return c is ('a'..='z' | 'A'..='Z' | '0'..='9' | '_')
}

///|
test "is word char" {
  for i in 0..<256 {
    let ch = i.unsafe_to_char()
    assert_eq(is_word_char(ch), char_in_ranges(ch, ranges_is_word))
  }
}

///|
/// Use binary search to check if a character is within any of the ranges.
/// The chars array contains pairs of characters [start1, end1, start2, end2, ...] 
/// representing ranges [start1-end1], [start2-end2], etc.
/// Assumes the ranges are sorted and non-overlapping.
fn char_in_ranges(ch : Char, chars : Array[Char]) -> Bool {
  let mut left = 0
  let mut right = chars.length() / 2 - 1
  while left <= right {
    let mid = (left + right) / 2
    let start = chars[mid * 2]
    let end = chars[mid * 2 + 1]
    if ch < start {
      right = mid - 1
    } else if ch > end {
      left = mid + 1
    } else {
      // ch is within the range [start, end]
      return true
    }
  }
  return false
}

///|
/// Simplifies a character class by merging overlapping ranges and removing duplicates.
/// Input: Array of characters representing ranges [start1, end1, start2, end2, ...]
/// Output: Simplified array with non-overlapping ranges in sorted order
fn simplify_char_ranges(chars : Array[Char]) -> Array[Char] {
  if chars.length() == 0 {
    return []
  }

  // Convert chars to array of ranges (start, end) pairs
  let ranges = []
  for i = 0; i < chars.length(); i = i + 2 {
    let start = chars[i]
    let end = chars[i + 1]
    ranges.push((start, end))
  }
  if ranges.length() == 0 {
    return []
  }

  // Sort ranges by start character
  ranges.sort_by_key(range => range.0)

  // Simplify ranges by merging overlapping or adjacent ranges
  let simplified = []
  let mut current_start = '\u{0}'
  let mut current_end = '\u{0}'
  if ranges.length() > 0 {
    current_start = ranges[0].0
    current_end = ranges[0].1
    for range in ranges[1:] {
      let (next_start, next_end) = range

      // Check if ranges overlap or are adjacent
      if next_start <= (current_end.to_int() + 1).unsafe_to_char() {
        // Merge ranges
        current_end = if current_end > next_end {
          current_end
        } else {
          next_end
        }
      } else {
        // Add current range to result and start new range
        simplified.push(current_start)
        simplified.push(current_end)
        current_start = next_start
        current_end = next_end
      }
    }

    // Add the last range
    simplified.push(current_start)
    simplified.push(current_end)
  }
  simplified
}

///|
/// Computes the complement of a character class.
/// Input: Array of characters representing ranges [start1, end1, start2, end2, ...]
/// Output: Array representing the complement ranges
fn compute_char_class_complement(chars : Array[Char]) -> Array[Char] {
  // First simplify the input ranges
  let simplified = simplify_char_ranges(chars)
  if simplified.length() == 0 {
    // Empty character class, complement is everything
    return ['\u{0}', '\u{10FFFF}']
  }
  let complement = []
  let min_char = '\u{0}'
  let max_char = '\u{10FFFF}'

  // Add range before first range if it doesn't start at minimum
  if simplified[0] > min_char {
    complement.push(min_char)
    complement.push((simplified[0].to_int() - 1).unsafe_to_char())
  }

  // Add gaps between ranges
  for i = 0; i < simplified.length() / 2 - 1; i = i + 1 {
    let current_end = simplified[i * 2 + 1]
    let next_start = simplified[(i + 1) * 2]
    let gap_start = (current_end.to_int() + 1).unsafe_to_char()
    let gap_end = (next_start.to_int() - 1).unsafe_to_char()
    if gap_start <= gap_end {
      complement.push(gap_start)
      complement.push(gap_end)
    }
  }

  // Add range after last range if it doesn't end at maximum
  let last_end = simplified[simplified.length() - 1]
  if last_end < max_char {
    complement.push((last_end.to_int() + 1).unsafe_to_char())
    complement.push(max_char)
  }
  complement
}

///|
test "compute complement of charclass" {
  assert_eq(ranges_is_digit, compute_char_class_complement(ranges_is_not_digit))
  assert_eq(ranges_is_not_digit, compute_char_class_complement(ranges_is_digit))
  assert_eq(ranges_is_word, compute_char_class_complement(ranges_is_not_word))
  assert_eq(ranges_is_not_word, compute_char_class_complement(ranges_is_word))
  assert_eq(
    ranges_is_not_white_space_or_line_terminator,
    compute_char_class_complement(ranges_is_white_space_or_line_terminator),
  )
}

///|
fn case_insensitive_char_class(chars : Array[Char]) -> Array[Char] {
  // This function should compute the case-insensitive character class
  // based on the provided character ranges.
  // For simplicity, we will just return the input for now.
  // In a real implementation, this would involve looking up case folding data.
  let result = []
  for i in 0..<(chars.length() / 2) {
    let mut start = chars[i * 2]
    let mut end = chars[i * 2 + 1]
    if (start <= MIN_FOLD && end >= MAX_FOLD) ||
      end < MIN_FOLD ||
      start > MAX_FOLD {
      // If the range is outside the simple case folding range, just add it
      result..push(start)..push(end)
      continue
    }
    if start < MIN_FOLD {
      result..push(start)..push((MIN_FOLD.to_int() - 1).unsafe_to_char())
      start = MIN_FOLD
    } else if end > MAX_FOLD {
      result..push((MAX_FOLD.to_int() + 1).unsafe_to_char())..push(end)
      end = MAX_FOLD
    } else {
      result..push(start)..push(end)
    }
    // For each character in the range, add its case-insensitive equivalents
    for c in start.to_int()..=end.to_int() {
      let char = c.unsafe_to_char()
      // Add both lower and upper case versions of the character
      if simple_case_folding_data.get(char) is Some(c) {
        for ch in reverse_simple_case_folding_data.get(c).unwrap() {
          result.push(ch)
          result.push(ch)
        }
      } else if reverse_simple_case_folding_data.get(char) is Some(array) {
        // If the character has a reverse mapping, add those as well
        for ch in array {
          result.push(ch)
          result.push(ch)
        }
      }
    }
  }
  simplify_char_ranges(result)
}

///|
test "case insensitive char class" {
  inspect(
    case_insensitive_char_class(['a', 'z']),
    content="['A', 'Z', 'a', 'z', 'ſ', 'ſ', 'K', 'K']",
  )
  inspect(
    case_insensitive_char_class(['A', 'Z']),
    content="['A', 'Z', 'ſ', 'ſ', 'K', 'K']",
  )
  inspect(
    case_insensitive_char_class(['\u{0}', '\n']),
    content="['\\u{00}', '\\n']",
  )
  inspect(
    case_insensitive_char_class(['!', 'z']),
    content="['!', 'Z', 'ſ', 'ſ', 'K', 'K']",
  )
  inspect(
    case_insensitive_char_class(['B', '🀄']),
    content="['A', 'Z', 'µ', 'µ', 'À', 'Ö', 'Ø', 'Þ', 'Ā', 'Ā', 'Ă', 'Ă', 'Ą', 'Ą', 'Ć', 'Ć', 'Ĉ', 'Ĉ', 'Ċ', 'Ċ', 'Č', 'Č', 'Ď', 'Ď', 'Đ', 'Đ', 'Ē', 'Ē', 'Ĕ', 'Ĕ', 'Ė', 'Ė', 'Ę', 'Ę', 'Ě', 'Ě', 'Ĝ', 'Ĝ', 'Ğ', 'Ğ', 'Ġ', 'Ġ', 'Ģ', 'Ģ', 'Ĥ', 'Ĥ', 'Ħ', 'Ħ', 'Ĩ', 'Ĩ', 'Ī', 'Ī', 'Ĭ', 'Ĭ', 'Į', 'Į', 'Ĳ', 'Ĳ', 'Ĵ', 'Ĵ', 'Ķ', 'Ķ', 'Ĺ', 'Ĺ', 'Ļ', 'Ļ', 'Ľ', 'Ľ', 'Ŀ', 'Ŀ', 'Ł', 'Ł', 'Ń', 'Ń', 'Ņ', 'Ņ', 'Ň', 'Ň', 'Ŋ', 'Ŋ', 'Ō', 'Ō', 'Ŏ', 'Ŏ', 'Ő', 'Ő', 'Œ', 'Œ', 'Ŕ', 'Ŕ', 'Ŗ', 'Ŗ', 'Ř', 'Ř', 'Ś', 'Ś', 'Ŝ', 'Ŝ', 'Ş', 'Ş', 'Š', 'Š', 'Ţ', 'Ţ', 'Ť', 'Ť', 'Ŧ', 'Ŧ', 'Ũ', 'Ũ', 'Ū', 'Ū', 'Ŭ', 'Ŭ', 'Ů', 'Ů', 'Ű', 'Ű', 'Ų', 'Ų', 'Ŵ', 'Ŵ', 'Ŷ', 'Ŷ', 'Ÿ', 'Ź', 'Ż', 'Ż', 'Ž', 'Ž', 'ſ', 'ſ', 'Ɓ', 'Ƃ', 'Ƅ', 'Ƅ', 'Ɔ', 'Ƈ', 'Ɖ', 'Ƌ', 'Ǝ', 'Ƒ', 'Ɠ', 'Ɣ', 'Ɩ', 'Ƙ', 'Ɯ', 'Ɲ', 'Ɵ', 'Ơ', 'Ƣ', 'Ƣ', 'Ƥ', 'Ƥ', 'Ʀ', 'Ƨ', 'Ʃ', 'Ʃ', 'Ƭ', 'Ƭ', 'Ʈ', 'Ư', 'Ʊ', 'Ƴ', 'Ƶ', 'Ƶ', 'Ʒ', 'Ƹ', 'Ƽ', 'Ƽ', 'Ǆ', 'ǅ', 'Ǉ', 'ǈ', 'Ǌ', 'ǋ', 'Ǎ', 'Ǎ', 'Ǐ', 'Ǐ', 'Ǒ', 'Ǒ', 'Ǔ', 'Ǔ', 'Ǖ', 'Ǖ', 'Ǘ', 'Ǘ', 'Ǚ', 'Ǚ', 'Ǜ', 'Ǜ', 'Ǟ', 'Ǟ', 'Ǡ', 'Ǡ', 'Ǣ', 'Ǣ', 'Ǥ', 'Ǥ', 'Ǧ', 'Ǧ', 'Ǩ', 'Ǩ', 'Ǫ', 'Ǫ', 'Ǭ', 'Ǭ', 'Ǯ', 'Ǯ', 'Ǳ', 'ǲ', 'Ǵ', 'Ǵ', 'Ƕ', 'Ǹ', 'Ǻ', 'Ǻ', 'Ǽ', 'Ǽ', 'Ǿ', 'Ǿ', 'Ȁ', 'Ȁ', 'Ȃ', 'Ȃ', 'Ȅ', 'Ȅ', 'Ȇ', 'Ȇ', 'Ȉ', 'Ȉ', 'Ȋ', 'Ȋ', 'Ȍ', 'Ȍ', 'Ȏ', 'Ȏ', 'Ȑ', 'Ȑ', 'Ȓ', 'Ȓ', 'Ȕ', 'Ȕ', 'Ȗ', 'Ȗ', 'Ș', 'Ș', 'Ț', 'Ț', 'Ȝ', 'Ȝ', 'Ȟ', 'Ȟ', 'Ƞ', 'Ƞ', 'Ȣ', 'Ȣ', 'Ȥ', 'Ȥ', 'Ȧ', 'Ȧ', 'Ȩ', 'Ȩ', 'Ȫ', 'Ȫ', 'Ȭ', 'Ȭ', 'Ȯ', 'Ȯ', 'Ȱ', 'Ȱ', 'Ȳ', 'Ȳ', 'Ⱥ', 'Ȼ', 'Ƚ', 'Ⱦ', 'Ɂ', 'Ɂ', 'Ƀ', 'Ɇ', 'Ɉ', 'Ɉ', 'Ɋ', 'Ɋ', 'Ɍ', 'Ɍ', 'Ɏ', 'Ɏ', 'ͅ', 'ͅ', 'Ͱ', 'Ͱ', 'Ͳ', 'Ͳ', 'Ͷ', 'Ͷ', 'Ϳ', 'Ϳ', 'Ά', 'Ά', 'Έ', 'Ί', 'Ό', 'Ό', 'Ύ', 'Ώ', 'Α', 'Ρ', 'Σ', 'Ϋ', 'ς', 'ς', 'Ϗ', 'ϑ', 'ϕ', 'ϖ', 'Ϙ', 'Ϙ', 'Ϛ', 'Ϛ', 'Ϝ', 'Ϝ', 'Ϟ', 'Ϟ', 'Ϡ', 'Ϡ', 'Ϣ', 'Ϣ', 'Ϥ', 'Ϥ', 'Ϧ', 'Ϧ', 'Ϩ', 'Ϩ', 'Ϫ', 'Ϫ', 'Ϭ', 'Ϭ', 'Ϯ', 'Ϯ', 'ϰ', 'ϱ', 'ϴ', 'ϵ', 'Ϸ', 'Ϸ', 'Ϲ', 'Ϻ', 'Ͻ', 'Я', 'Ѡ', 'Ѡ', 'Ѣ', 'Ѣ', 'Ѥ', 'Ѥ', 'Ѧ', 'Ѧ', 'Ѩ', 'Ѩ', 'Ѫ', 'Ѫ', 'Ѭ', 'Ѭ', 'Ѯ', 'Ѯ', 'Ѱ', 'Ѱ', 'Ѳ', 'Ѳ', 'Ѵ', 'Ѵ', 'Ѷ', 'Ѷ', 'Ѹ', 'Ѹ', 'Ѻ', 'Ѻ', 'Ѽ', 'Ѽ', 'Ѿ', 'Ѿ', 'Ҁ', 'Ҁ', 'Ҋ', 'Ҋ', 'Ҍ', 'Ҍ', 'Ҏ', 'Ҏ', 'Ґ', 'Ґ', 'Ғ', 'Ғ', 'Ҕ', 'Ҕ', 'Җ', 'Җ', 'Ҙ', 'Ҙ', 'Қ', 'Қ', 'Ҝ', 'Ҝ', 'Ҟ', 'Ҟ', 'Ҡ', 'Ҡ', 'Ң', 'Ң', 'Ҥ', 'Ҥ', 'Ҧ', 'Ҧ', 'Ҩ', 'Ҩ', 'Ҫ', 'Ҫ', 'Ҭ', 'Ҭ', 'Ү', 'Ү', 'Ұ', 'Ұ', 'Ҳ', 'Ҳ', 'Ҵ', 'Ҵ', 'Ҷ', 'Ҷ', 'Ҹ', 'Ҹ', 'Һ', 'Һ', 'Ҽ', 'Ҽ', 'Ҿ', 'Ҿ', 'Ӏ', 'Ӂ', 'Ӄ', 'Ӄ', 'Ӆ', 'Ӆ', 'Ӈ', 'Ӈ', 'Ӊ', 'Ӊ', 'Ӌ', 'Ӌ', 'Ӎ', 'Ӎ', 'Ӑ', 'Ӑ', 'Ӓ', 'Ӓ', 'Ӕ', 'Ӕ', 'Ӗ', 'Ӗ', 'Ә', 'Ә', 'Ӛ', 'Ӛ', 'Ӝ', 'Ӝ', 'Ӟ', 'Ӟ', 'Ӡ', 'Ӡ', 'Ӣ', 'Ӣ', 'Ӥ', 'Ӥ', 'Ӧ', 'Ӧ', 'Ө', 'Ө', 'Ӫ', 'Ӫ', 'Ӭ', 'Ӭ', 'Ӯ', 'Ӯ', 'Ӱ', 'Ӱ', 'Ӳ', 'Ӳ', 'Ӵ', 'Ӵ', 'Ӷ', 'Ӷ', 'Ӹ', 'Ӹ', 'Ӻ', 'Ӻ', 'Ӽ', 'Ӽ', 'Ӿ', 'Ӿ', 'Ԁ', 'Ԁ', 'Ԃ', 'Ԃ', 'Ԅ', 'Ԅ', 'Ԇ', 'Ԇ', 'Ԉ', 'Ԉ', 'Ԋ', 'Ԋ', 'Ԍ', 'Ԍ', 'Ԏ', 'Ԏ', 'Ԑ', 'Ԑ', 'Ԓ', 'Ԓ', 'Ԕ', 'Ԕ', 'Ԗ', 'Ԗ', 'Ԙ', 'Ԙ', 'Ԛ', 'Ԛ', 'Ԝ', 'Ԝ', 'Ԟ', 'Ԟ', 'Ԡ', 'Ԡ', 'Ԣ', 'Ԣ', 'Ԥ', 'Ԥ', 'Ԧ', 'Ԧ', 'Ԩ', 'Ԩ', 'Ԫ', 'Ԫ', 'Ԭ', 'Ԭ', 'Ԯ', 'Ԯ', 'Ա', 'Ֆ', 'Ⴀ', 'Ⴥ', 'Ⴧ', 'Ⴧ', 'Ⴭ', 'Ⴭ', 'ᏸ', 'ᏽ', 'ᲀ', 'Ᲊ', 'Ა', 'Ჺ', 'Ჽ', 'Ჿ', 'Ḁ', 'Ḁ', 'Ḃ', 'Ḃ', 'Ḅ', 'Ḅ', 'Ḇ', 'Ḇ', 'Ḉ', 'Ḉ', 'Ḋ', 'Ḋ', 'Ḍ', 'Ḍ', 'Ḏ', 'Ḏ', 'Ḑ', 'Ḑ', 'Ḓ', 'Ḓ', 'Ḕ', 'Ḕ', 'Ḗ', 'Ḗ', 'Ḙ', 'Ḙ', 'Ḛ', 'Ḛ', 'Ḝ', 'Ḝ', 'Ḟ', 'Ḟ', 'Ḡ', 'Ḡ', 'Ḣ', 'Ḣ', 'Ḥ', 'Ḥ', 'Ḧ', 'Ḧ', 'Ḩ', 'Ḩ', 'Ḫ', 'Ḫ', 'Ḭ', 'Ḭ', 'Ḯ', 'Ḯ', 'Ḱ', 'Ḱ', 'Ḳ', 'Ḳ', 'Ḵ', 'Ḵ', 'Ḷ', 'Ḷ', 'Ḹ', 'Ḹ', 'Ḻ', 'Ḻ', 'Ḽ', 'Ḽ', 'Ḿ', 'Ḿ', 'Ṁ', 'Ṁ', 'Ṃ', 'Ṃ', 'Ṅ', 'Ṅ', 'Ṇ', 'Ṇ', 'Ṉ', 'Ṉ', 'Ṋ', 'Ṋ', 'Ṍ', 'Ṍ', 'Ṏ', 'Ṏ', 'Ṑ', 'Ṑ', 'Ṓ', 'Ṓ', 'Ṕ', 'Ṕ', 'Ṗ', 'Ṗ', 'Ṙ', 'Ṙ', 'Ṛ', 'Ṛ', 'Ṝ', 'Ṝ', 'Ṟ', 'Ṟ', 'Ṡ', 'Ṡ', 'Ṣ', 'Ṣ', 'Ṥ', 'Ṥ', 'Ṧ', 'Ṧ', 'Ṩ', 'Ṩ', 'Ṫ', 'Ṫ', 'Ṭ', 'Ṭ', 'Ṯ', 'Ṯ', 'Ṱ', 'Ṱ', 'Ṳ', 'Ṳ', 'Ṵ', 'Ṵ', 'Ṷ', 'Ṷ', 'Ṹ', 'Ṹ', 'Ṻ', 'Ṻ', 'Ṽ', 'Ṽ', 'Ṿ', 'Ṿ', 'Ẁ', 'Ẁ', 'Ẃ', 'Ẃ', 'Ẅ', 'Ẅ', 'Ẇ', 'Ẇ', 'Ẉ', 'Ẉ', 'Ẋ', 'Ẋ', 'Ẍ', 'Ẍ', 'Ẏ', 'Ẏ', 'Ẑ', 'Ẑ', 'Ẓ', 'Ẓ', 'Ẕ', 'Ẕ', 'ẛ', 'ẛ', 'ẞ', 'ẞ', 'Ạ', 'Ạ', 'Ả', 'Ả', 'Ấ', 'Ấ', 'Ầ', 'Ầ', 'Ẩ', 'Ẩ', 'Ẫ', 'Ẫ', 'Ậ', 'Ậ', 'Ắ', 'Ắ', 'Ằ', 'Ằ', 'Ẳ', 'Ẳ', 'Ẵ', 'Ẵ', 'Ặ', 'Ặ', 'Ẹ', 'Ẹ', 'Ẻ', 'Ẻ', 'Ẽ', 'Ẽ', 'Ế', 'Ế', 'Ề', 'Ề', 'Ể', 'Ể', 'Ễ', 'Ễ', 'Ệ', 'Ệ', 'Ỉ', 'Ỉ', 'Ị', 'Ị', 'Ọ', 'Ọ', 'Ỏ', 'Ỏ', 'Ố', 'Ố', 'Ồ', 'Ồ', 'Ổ', 'Ổ', 'Ỗ', 'Ỗ', 'Ộ', 'Ộ', 'Ớ', 'Ớ', 'Ờ', 'Ờ', 'Ở', 'Ở', 'Ỡ', 'Ỡ', 'Ợ', 'Ợ', 'Ụ', 'Ụ', 'Ủ', 'Ủ', 'Ứ', 'Ứ', 'Ừ', 'Ừ', 'Ử', 'Ử', 'Ữ', 'Ữ', 'Ự', 'Ự', 'Ỳ', 'Ỳ', 'Ỵ', 'Ỵ', 'Ỷ', 'Ỷ', 'Ỹ', 'Ỹ', 'Ỻ', 'Ỻ', 'Ỽ', 'Ỽ', 'Ỿ', 'Ỿ', 'Ἀ', 'Ἇ', 'Ἐ', 'Ἕ', 'Ἠ', 'Ἧ', 'Ἰ', 'Ἷ', 'Ὀ', 'Ὅ', 'Ὑ', 'Ὑ', 'Ὓ', 'Ὓ', 'Ὕ', 'Ὕ', 'Ὗ', 'Ὗ', 'Ὠ', 'Ὧ', 'ᾈ', 'ᾏ', 'ᾘ', 'ᾟ', 'ᾨ', 'ᾯ', 'Ᾰ', 'ᾼ', 'ι', 'ι', 'Ὲ', 'ῌ', 'ΐ', 'ΐ', 'Ῐ', 'Ί', 'ΰ', 'ΰ', 'Ῠ', 'Ῥ', 'Ὸ', 'ῼ', 'Ω', 'Ω', 'K', 'Å', 'Ⅎ', 'Ⅎ', 'Ⅰ', 'Ⅿ', 'Ↄ', 'Ↄ', 'Ⓐ', 'Ⓩ', 'Ⰰ', 'Ⱟ', 'Ⱡ', 'Ⱡ', 'Ɫ', 'Ɽ', 'Ⱨ', 'Ⱨ', 'Ⱪ', 'Ⱪ', 'Ⱬ', 'Ⱬ', 'Ɑ', 'Ɒ', 'Ⱳ', 'Ⱳ', 'Ⱶ', 'Ⱶ', 'Ȿ', 'Ⲁ', 'Ⲃ', 'Ⲃ', 'Ⲅ', 'Ⲅ', 'Ⲇ', 'Ⲇ', 'Ⲉ', 'Ⲉ', 'Ⲋ', 'Ⲋ', 'Ⲍ', 'Ⲍ', 'Ⲏ', 'Ⲏ', 'Ⲑ', 'Ⲑ', 'Ⲓ', 'Ⲓ', 'Ⲕ', 'Ⲕ', 'Ⲗ', 'Ⲗ', 'Ⲙ', 'Ⲙ', 'Ⲛ', 'Ⲛ', 'Ⲝ', 'Ⲝ', 'Ⲟ', 'Ⲟ', 'Ⲡ', 'Ⲡ', 'Ⲣ', 'Ⲣ', 'Ⲥ', 'Ⲥ', 'Ⲧ', 'Ⲧ', 'Ⲩ', 'Ⲩ', 'Ⲫ', 'Ⲫ', 'Ⲭ', 'Ⲭ', 'Ⲯ', 'Ⲯ', 'Ⲱ', 'Ⲱ', 'Ⲳ', 'Ⲳ', 'Ⲵ', 'Ⲵ', 'Ⲷ', 'Ⲷ', 'Ⲹ', 'Ⲹ', 'Ⲻ', 'Ⲻ', 'Ⲽ', 'Ⲽ', 'Ⲿ', 'Ⲿ', 'Ⳁ', 'Ⳁ', 'Ⳃ', 'Ⳃ', 'Ⳅ', 'Ⳅ', 'Ⳇ', 'Ⳇ', 'Ⳉ', 'Ⳉ', 'Ⳋ', 'Ⳋ', 'Ⳍ', 'Ⳍ', 'Ⳏ', 'Ⳏ', 'Ⳑ', 'Ⳑ', 'Ⳓ', 'Ⳓ', 'Ⳕ', 'Ⳕ', 'Ⳗ', 'Ⳗ', 'Ⳙ', 'Ⳙ', 'Ⳛ', 'Ⳛ', 'Ⳝ', 'Ⳝ', 'Ⳟ', 'Ⳟ', 'Ⳡ', 'Ⳡ', 'Ⳣ', 'Ⳣ', 'Ⳬ', 'Ⳬ', 'Ⳮ', 'Ⳮ', 'Ⳳ', 'Ⳳ', 'Ꙁ', 'Ꙁ', 'Ꙃ', 'Ꙃ', 'Ꙅ', 'Ꙅ', 'Ꙇ', 'Ꙇ', 'Ꙉ', 'Ꙉ', 'Ꙋ', 'Ꙋ', 'Ꙍ', 'Ꙍ', 'Ꙏ', 'Ꙏ', 'Ꙑ', 'Ꙑ', 'Ꙓ', 'Ꙓ', 'Ꙕ', 'Ꙕ', 'Ꙗ', 'Ꙗ', 'Ꙙ', 'Ꙙ', 'Ꙛ', 'Ꙛ', 'Ꙝ', 'Ꙝ', 'Ꙟ', 'Ꙟ', 'Ꙡ', 'Ꙡ', 'Ꙣ', 'Ꙣ', 'Ꙥ', 'Ꙥ', 'Ꙧ', 'Ꙧ', 'Ꙩ', 'Ꙩ', 'Ꙫ', 'Ꙫ', 'Ꙭ', 'Ꙭ', 'Ꚁ', 'Ꚁ', 'Ꚃ', 'Ꚃ', 'Ꚅ', 'Ꚅ', 'Ꚇ', 'Ꚇ', 'Ꚉ', 'Ꚉ', 'Ꚋ', 'Ꚋ', 'Ꚍ', 'Ꚍ', 'Ꚏ', 'Ꚏ', 'Ꚑ', 'Ꚑ', 'Ꚓ', 'Ꚓ', 'Ꚕ', 'Ꚕ', 'Ꚗ', 'Ꚗ', 'Ꚙ', 'Ꚙ', 'Ꚛ', 'Ꚛ', 'Ꜣ', 'Ꜣ', 'Ꜥ', 'Ꜥ', 'Ꜧ', 'Ꜧ', 'Ꜩ', 'Ꜩ', 'Ꜫ', 'Ꜫ', 'Ꜭ', 'Ꜭ', 'Ꜯ', 'Ꜯ', 'Ꜳ', 'Ꜳ', 'Ꜵ', 'Ꜵ', 'Ꜷ', 'Ꜷ', 'Ꜹ', 'Ꜹ', 'Ꜻ', 'Ꜻ', 'Ꜽ', 'Ꜽ', 'Ꜿ', 'Ꜿ', 'Ꝁ', 'Ꝁ', 'Ꝃ', 'Ꝃ', 'Ꝅ', 'Ꝅ', 'Ꝇ', 'Ꝇ', 'Ꝉ', 'Ꝉ', 'Ꝋ', 'Ꝋ', 'Ꝍ', 'Ꝍ', 'Ꝏ', 'Ꝏ', 'Ꝑ', 'Ꝑ', 'Ꝓ', 'Ꝓ', 'Ꝕ', 'Ꝕ', 'Ꝗ', 'Ꝗ', 'Ꝙ', 'Ꝙ', 'Ꝛ', 'Ꝛ', 'Ꝝ', 'Ꝝ', 'Ꝟ', 'Ꝟ', 'Ꝡ', 'Ꝡ', 'Ꝣ', 'Ꝣ', 'Ꝥ', 'Ꝥ', 'Ꝧ', 'Ꝧ', 'Ꝩ', 'Ꝩ', 'Ꝫ', 'Ꝫ', 'Ꝭ', 'Ꝭ', 'Ꝯ', 'Ꝯ', 'Ꝺ', 'Ꝺ', 'Ꝼ', 'Ꝼ', 'Ᵹ', 'Ꝿ', 'Ꞁ', 'Ꞁ', 'Ꞃ', 'Ꞃ', 'Ꞅ', 'Ꞅ', 'Ꞇ', 'Ꞇ', 'Ꞌ', 'Ꞌ', 'Ɥ', 'Ɥ', 'Ꞑ', 'Ꞑ', 'Ꞓ', 'Ꞓ', 'Ꞗ', 'Ꞗ', 'Ꞙ', 'Ꞙ', 'Ꞛ', 'Ꞛ', 'Ꞝ', 'Ꞝ', 'Ꞟ', 'Ꞟ', 'Ꞡ', 'Ꞡ', 'Ꞣ', 'Ꞣ', 'Ꞥ', 'Ꞥ', 'Ꞧ', 'Ꞧ', 'Ꞩ', 'Ꞩ', 'Ɦ', 'Ɪ', 'Ʞ', 'Ꞵ', 'Ꞷ', 'Ꞷ', 'Ꞹ', 'Ꞹ', 'Ꞻ', 'Ꞻ', 'Ꞽ', 'Ꞽ', 'Ꞿ', 'Ꞿ', 'Ꟁ', 'Ꟁ', 'Ꟃ', 'Ꟃ', 'Ꞔ', 'Ꟈ', 'Ꟊ', 'Ꟊ', 'Ɤ', 'Ꟍ', 'Ꟑ', 'Ꟑ', 'Ꟗ', 'Ꟗ', 'Ꟙ', 'Ꟙ', 'Ꟛ', 'Ꟛ', 'Ƛ', 'Ƛ', 'Ꟶ', 'Ꟶ', 'ꭰ', 'ꮿ', 'ﬅ', 'ﬅ', 'Ａ', 'Ｚ', '𐐀', '𐐧', '𐒰', '𐓓', '𐕰', '𐕺', '𐕼', '𐖊', '𐖌', '𐖒', '𐖔', '𐖕', '𐲀', '𐲲', '𐵐', '𐵥', '𑢠', '𑢿', '𖹀', '𖹟', '𞤀', '𞤡', '𞥄', '🀄']",
  )
  inspect(
    case_insensitive_char_class(['🀄', '🀡']),
    content="['🀄', '🀡']",
  )
}
