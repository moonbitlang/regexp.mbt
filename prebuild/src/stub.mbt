// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///| Run the program.
pub fn run() -> Result[Unit, Unit] {
  let mut result = Ok(())
  @promise.spawn(async fn(_defer) {
    top() catch {
      error => {
        result = Err(())
        @io.println_sync("Error \{error}", stream=@io.stderr)
      }
    }
  })
  |> ignore
  @io.event_loop.run()
  result
}

///|
/// User should change this function to do what they want
async fn top() -> Unit raise {
  // Get the case folding data from Unicode.org
  let request = @http.request(
    "www.unicode.org",
    path="/Public/UCD/latest/ucd/CaseFolding.txt",
  )
  let data = @http.fetch(request)
  guard data.consume() is Ok(body)
  guard body.stream() is Ok(input_stream)

  // We only do simple case folding
  let regexp = @regexp.compile("^([0-9A-F]+);\\s+[CS];\\s+([0-9A-F]+);")
  let mappings = []
  while true {
    let next = @io.read_line(stream=input_stream)
    if next.contains("EOF") {
      break
    }
    let result = regexp.execute(next)
    if result.matched() {
      mappings.push(
        (
          result.group(1).unwrap()
          |> @string.View::to_string
          |> @strconv.parse_int(base=16)
          |> Int::unsafe_to_char(),
          result.group(2).unwrap()
          |> @string.View::to_string
          |> @strconv.parse_int(base=16)
          |> Int::unsafe_to_char(),
        ),
      )
    }
  }
  input_stream.drop()
  body.drop()
  data.drop()

  // Compute reverse mapping
  let mut min = '\u{10FFFF}'
  let mut max = '\u{0000}'
  let reverse : Map[Char, Array[Char]] = {}
  for mapping in mappings {
    let (k, v) = mapping
    min = min |> @math.minimum(k) |> @math.minimum(v)
    max = max |> @math.maximum(k) |> @math.maximum(v)
    if reverse.get(v) is Some(array) {
      array.push(k)
    } else {
      reverse[v] = [k]
    }
  }

  // Prepare file. Assume preopen is where the file needs to be written
  guard @preopens.get_directories() is [(preopen, _), ..] else {
    fail("Error: No preopen directories found")
  }
  let file = preopen
    .open_at(
      @fs.PathFlags::default(),
      "case_folding.mbt",
      @fs.OpenFlags::default().set(CREATE).set(TRUNCATE),
      @fs.DescriptorFlags::default().set(@fs.DescriptorFlagsFlag::WRITE),
    )
    .unwrap_or_error()
  let output_stream = file.write_via_stream(0).unwrap_or_error()

  // Start writing template
  @io.println(
    #|// generated by prebuild : just -d ./prebuild -f ./prebuild/justfile run
    #|
    #|///|
    #|let simple_case_folding_data : Map[Char, Char] = {
    ,
    stream=output_stream,
  )
  for mapping in mappings {
    let (k, v) = mapping
    @io.println(
      $|  '\\u{\{k.to_int().to_string(radix=16)}}': '\\u{\{v.to_int().to_string(radix=16)}}',
      ,
      stream=output_stream,
    )
  }
  @io.println(
    #|}
    #|
    #|///|
    #|let reverse_simple_case_folding_data : Map[Char, Array[Char]] = {
    ,
    stream=output_stream,
  )
  for v in reverse.to_array() {
    let (k, v) = v
    let array = v
      .map(c => "'\\u{\{c.to_int().to_string(radix=16)}}'")
      .join(", ")
    @io.println(
      $|  '\\u{\{k.to_int().to_string(radix=16)}}': [\{array}],
      ,
      stream=output_stream,
    )
  }
  @io.println(
    #|}
    #|
    #|///|
    $|const MIN_FOLD : Char = '\\u{\{min.to_int().to_string(radix=16)}}'
    $|
    $|///|
    $|const MAX_FOLD : Char = '\\u{\{max.to_int().to_string(radix=16)}}'
    ,
    stream=output_stream,
  )
  output_stream.blocking_flush().unwrap()
  output_stream.drop()
  file.drop()
}
