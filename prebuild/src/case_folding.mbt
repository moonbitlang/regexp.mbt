// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
async fn get_case_folding_mapping(
  defer_ : (() -> Unit) -> Unit
) -> Array[(Char, Char)] raise {
  // Get the case folding data from Unicode.org
  let request = @http.request(
    UNICODE_ADDRESS,
    path=UNICODE_DATABASE_PATH + "/CaseFolding.txt",
  )
  let data = @http.fetch(request)
  defer_(() => data.drop())
  guard data.consume() is Ok(body)
  defer_(() => body.drop())
  guard body.stream() is Ok(input_stream)
  defer_(() => input_stream.drop())

  // We only do simple case folding
  let regexp = @regexp.compile("^([0-9A-F]+);\\s+[CS];\\s+([0-9A-F]+);")
  let mappings = []
  while true {
    let next = @io.read_line(stream=input_stream)
    if next.contains("EOF") {
      break
    }
    let result = regexp.execute(next)
    if result.matched() {
      mappings.push(
        (
          result.get(1).unwrap()
          |> @string.View::to_string
          |> @strconv.parse_int(base=16)
          |> Int::unsafe_to_char(),
          result.get(2).unwrap()
          |> @string.View::to_string
          |> @strconv.parse_int(base=16)
          |> Int::unsafe_to_char(),
        ),
      )
    }
  }
  mappings
}

///|
async fn handle_case_folding(defer_ : (() -> Unit) -> Unit) -> Unit raise {
  let mappings = @promise.spawn(get_case_folding_mapping).await()

  // Compute reverse mapping
  let mut min = '\u{10FFFF}'
  let mut max = '\u{0000}'
  let reverse : Map[Char, Array[Char]] = {}
  for mapping in mappings {
    let (k, v) = mapping
    min = min |> @cmp.minimum(k) |> @cmp.minimum(v)
    max = max |> @cmp.maximum(k) |> @cmp.maximum(v)
    if reverse.get(v) is Some(array) {
      array.push(k)
    } else {
      reverse[v] = [k]
    }
  }

  // Prepare file. Assume preopen is where the file needs to be written
  guard @preopens.get_directories() is [(preopen, _), ..] else {
    fail("Error: No preopen directories found")
  }
  let file = preopen
    .open_at(
      @fs.PathFlags::default(),
      "case_folding.mbt",
      @fs.OpenFlags::default().set(CREATE).set(TRUNCATE),
      @fs.DescriptorFlags::default().set(@fs.DescriptorFlagsFlag::WRITE),
    )
    .unwrap_or_error()
  defer_(() => file.drop())
  let output_stream = file.write_via_stream(0).unwrap_or_error()
  defer_(() => output_stream.drop())

  // Start writing template
  @io.print(
    (
      #|// generated by prebuild : just -d ./prebuild -f ./prebuild/justfile run
      #|
      #|///|
      #|const DATA : String = $|
    ),
    stream=output_stream,
  )
  for mapping in reverse.to_array() {
    let (key, mapping) = mapping
    let mut prev = key
    for ch in mapping {
      @io.print(
        (
          $|\\u{\{prev.to_int().to_string(radix=16)}}\\u{\{ch.to_int().to_string(radix=16)}}
        ),
        stream=output_stream,
      )
      prev = ch
    }
    @io.print(
      (
        $|\\u{\{prev.to_int().to_string(radix=16)}}\\u{\{key.to_int().to_string(radix=16)}}
      ),
      stream=output_stream,
    )
  }
  @io.println(
    (
      #|
      #|///|
      #|pub let case_folding : Map[Char, Char] = {
      #|  let map = {}
      #|  loop DATA[:] {
      #|    [ch1, ch2, .. rest ] => {
      #|      map[ch1] = ch2
      #|      continue rest
      #|    }
      #|    [_] => panic()
      #|    [] => ()
      #|  }
      #|  map
      #|}
      #|
      #|///|
      $|pub const MIN_FOLD : Char = '\\u{\{min.to_int().to_string(radix=16)}}'
      $|
      $|///|
      $|pub const MAX_FOLD : Char = '\\u{\{max.to_int().to_string(radix=16)}}'
    ),
    stream=output_stream,
  )
  output_stream.blocking_flush().unwrap()
}
